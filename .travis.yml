sudo: required
language: java
jdk:
  - openjdk8
env:
  global:
    - IMAGE_NAME=bluecompute-customer
    - RELEASE_NAME=customer
    - TAG=travis-latest
    - HS256_KEY=E6526VJkKYhyTFRFMC0pTECpHcZ7TGcq8pKsVVgz9KtESVpheEO284qKzfzg8HpWNBPeHOxNGlyudUHi6i8tFQJXC8PiI48RUpMh23vPDLGD35pCM0417gf58z5xlmRNii56fwRCmIhhV7hDsm3KO2jRv4EBVz7HrYbzFeqI45CaStkMYNipzSm2duuer7zRdMjEKIdqsby0JfpQpykHmC5L6hxkX0BT7XWqztTr6xHCwqst26O0g8r7bXSYjp4a
    - COUCHDB_USER=admin
    - COUCHDB_USER=passw0rd
stages:
  - local build and test
  - docker build, deploy, and test
  - kubernetes build, deploy, and test
jobs:
  include:
    - stage: local build and test
      services:
      - couchdb
      before_cache:
        - rm -f  $HOME/.gradle/caches/modules-2/modules-2.lock
        - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
      cache:
        directories:
          - $HOME/.gradle/caches/
          - $HOME/.gradle/wrapper/
      before_script:
      # Create admin user in CouchDB
      - curl -X PUT http://127.0.0.1:5984/_node/nonode@nohost/_config/admins/admin -d '"passw0rd"'
      # Create JWT Token:
      # Secret Key
      - secret=${HS256_KEY};
      # JWT Header
      - jwt1=$(echo -n '{"alg":"HS256","typ":"JWT"}' | openssl enc -base64);
      # JWT Payload
      - jwt2=$(echo -n "{\"scope\":[\"admin\"],\"user_name\":\"${COUCHDB_USER}\"}" | openssl enc -base64);
      # JWT Signature: Header and Payload
      - jwt3=$(echo -n "${jwt1}.${jwt2}" | tr '+\/' '-_' | tr -d '=' | tr -d '\r\n');
      # JWT Signature: Create signed hash with secret key
      - jwt4=$(echo -n "${jwt3}" | openssl dgst -binary -sha256 -hmac "${secret}" | openssl enc -base64 | tr '+\/' '-_' | tr -d '=' | tr -d '\r\n');
      # Complete JWT
      - jwt=$(echo -n "${jwt3}.${jwt4}");
      script:
      # Gradle Build
      - ./gradlew build -x test
      # Start Application
      - java -Deureka.client.fetchRegistry=false -Deureka.client.registerWithEureka=false -Djwt.sharedSecret=${HS256_KEY} -jar build/libs/micro-customer-0.0.1.jar &
      # Wait for the Inventory container to start accepting connections
      - sleep 25
      # Run Inventory API Test
      # TODO: Test more APIs, perhaps with a separate script
      # TEST: Create User
      - curl -X POST http://127.0.0.1:8080/micro/customer -H "Content-type: application/json" -H "Authorization: Bearer ${jwt}" -d "{\"username\": \"${COUCHDB_USER}\", \"password\": \"${COUCHDB_PASSWORD}\", \"firstName\": \"user\", \"lastName\": \"name\", \"email\": \"user@name.com\"}"
      # TEST: Search User
      - curl -X GET 'http://127.0.0.1:8080/micro/customer/search?username=admin' -H 'Content-type: application/json' -H "Authorization: Bearer ${jwt}" 
      - curl http://127.0.0.1:8080/micro/customer
    - stage: docker build, deploy, and test
      services:
      - couchdb
      - docker
      install:
        - true
      before_script:
      # Create admin user in CouchDB
      - curl -X PUT http://127.0.0.1:5984/_node/nonode@nohost/_config/admins/admin -d '"passw0rd"'
      # Create JWT Token:
      # Secret Key
      - secret=${HS256_KEY};
      # JWT Header
      - jwt1=$(echo -n '{"alg":"HS256","typ":"JWT"}' | openssl enc -base64);
      # JWT Payload
      - jwt2=$(echo -n "{\"scope\":[\"admin\"],\"user_name\":\"${COUCHDB_USER}\"}" | openssl enc -base64);
      # JWT Signature: Header and Payload
      - jwt3=$(echo -n "${jwt1}.${jwt2}" | tr '+\/' '-_' | tr -d '=' | tr -d '\r\n');
      # JWT Signature: Create signed hash with secret key
      - jwt4=$(echo -n "${jwt3}" | openssl dgst -binary -sha256 -hmac "${secret}" | openssl enc -base64 | tr '+\/' '-_' | tr -d '=' | tr -d '\r\n');
      # Complete JWT
      - jwt=$(echo -n "${jwt3}.${jwt4}");
      script:
      # Build Docker image
      - docker build -t "${IMAGE_NAME}:${TAG}" .
      # Start Inventory Container and Connect to local MySQL Service
      - docker run --net=host --name customer -d -p 8080:8080 -e COUCHDB_URI="couchdb://root@127.0.0.1:3306/customers" "${IMAGE_NAME}:${TAG}"
      # Wait for the Inventory container to start accepting connections
      - sleep 25
      # Check that the Inventory container is running
      - docker ps
      # Check logs to see if it started properly
      - docker logs customer
      # Run Inventory API Test
      # TODO: Test more APIs, perhaps with a separate script
      # TEST: Create User
      - curl -X POST http://127.0.0.1:8080/micro/customer -H "Content-type: application/json" -H "Authorization: Bearer ${jwt}" -d "{\"username\": \"${COUCHDB_USER}\", \"password\": \"${COUCHDB_PASSWORD}\", \"firstName\": \"user\", \"lastName\": \"name\", \"email\": \"user@name.com\"}"
      # TEST: Search User
      - curl -X GET 'http://127.0.0.1:8080/micro/customer/search?username=admin' -H 'Content-type: application/json' -H "Authorization: Bearer ${jwt}" 
    - stage: kubernetes build, deploy, and test
      services:
      - docker
      env:
      - CHANGE_MINIKUBE_NONE_USER=true
      install:
        - true
      before_script:
      # Install nsenter, which is needed for minikube to work
      - bash scripts/install_nsenter.sh 
      # Download kubectl, which is a requirement for using minikube.
      - curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/
      # Download minikube.
      - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.25.2/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/
      - sudo minikube start --vm-driver=none --kubernetes-version=v1.9.0
      # Fix the kubectl context, as it's often stale.
      - minikube update-context
      # Getting ip for testing
      - minikube ip
      # Wait for Minikube to be up and ready.
      - JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}'; until kubectl get nodes -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do sleep 1; done
      # Download Helm CLI
      - curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get > get_helm.sh && chmod 700 get_helm.sh && ./get_helm.sh && rm get_helm.sh
      # Create Tiller Service Account
      - kubectl -n kube-system create sa tiller && kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
      # Install Helm on Minikube
      - helm init --service-account tiller
      # Wait for helm to be ready
      - until helm list; do echo "waiting for helm to be ready"; sleep 1; done
      # Add incubator Helm repo
      - helm repo add incubator http://storage.googleapis.com/kubernetes-charts-incubator
      script:
      # Get cluster info
      - kubectl cluster-info
      # Build Docker image
      - docker build -t "${IMAGE_NAME}:${TAG}" .
      # Download Inventory chart dependencies (MySQL)
      - cd chart/customer; helm dependency update; cd ../..
      # helm lint
      - helm lint chart/customer
      # helm package
      - helm package chart/customer
      # helm install Inventory from packaged chart. Use pullPolicy=Never so it uses local docker image
      - CHART_VERSION="$(cat chart/customer/Chart.yaml | grep version | awk '{print $2}')"
      - helm upgrade --install customer --set service.type=NodePort,image.repository="${IMAGE_NAME}",image.tag="${TAG}",image.pullPolicy=Never customer-${CHART_VERSION}.tgz
      # Wait for Inventory to be ready
      - kubectl get deployments ${RELEASE_NAME}-customer -o yaml
      - READY=$(kubectl get deployments ${RELEASE_NAME}-customer -o yaml | grep "readyReplicas" | awk '{print $2}')
      - echo $READY
      - until [ -n "$READY" ] && [ ${READY} -ge 1 ]; do READY=$(kubectl get deployments ${RELEASE_NAME}-customer -o yaml | grep "readyReplicas" | awk '{print $2}'); kubectl get deployments -o wide; echo "Waiting for customer to be ready"; sleep 10; done
      # Wait for Inventory deployment to start accepting connections
      - sleep 35
      # Run Inventory API Test
      - NODE_PORT=$(kubectl get service ${RELEASE_NAME}-customer -o=jsonpath='{.spec.ports[0].nodePort}')
      # TEST: Create User
      - curl -X POST http://$(minikube ip):${NODE_PORT}/micro/customer -H "Content-type: application/json" -H "Authorization: Bearer ${jwt}" -d "{\"username\": \"${COUCHDB_USER}\", \"password\": \"${COUCHDB_PASSWORD}\", \"firstName\": \"user\", \"lastName\": \"name\", \"email\": \"user@name.com\"}"
      # TEST: Search User
      - curl -X GET 'http://$(minikube ip):${NODE_PORT}/micro/customer/search?username=admin' -H 'Content-type: application/json' -H "Authorization: Bearer ${jwt}" 